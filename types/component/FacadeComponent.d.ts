import { ApproachableAlignment, ApproachableComponent } from "./ApproachableComponent";
import { Serializable } from "../core/Serializable";
import { Component } from "./Component";
import { TypeName, CapturePriority, FacadeBoundaryFace, FacadePattern, CameraMode, PathCornering, CameraPhotoMode, CameraFocusMode, FacadeSegmentParity, ExecutionEngine, FacadeSpacing } from "../core/Enums";
import { CameraSpecification, GroundSampleDistance } from "../core/CameraSpecification";
import { FacadeComponentBoundaryPoint } from "./FacadeComponentBoundaryPoint";
import { Altitude } from "../core/Altitude";
import { Vector2 } from "../core/Vector2";
import { GeoCoordinate } from "../core/GeoCoordinate";
import { Line2 } from "../core/Line2";
import { Path } from "../core/Path";
import { ComponentNode } from "./ComponentNode";
import { Node } from "../core/Node";
import { ComponentEstimateContext } from "./ComponentEstimateContext";
import { GeoSpatial } from "../core/GeoSpatial";
import { ComponentEstimate } from "./ComponentEstimate";
import { Orientation3Optional } from "../core/Orientation3Optional";
import { Dictionary } from "../core/Dictionary";
import { ComponentExecuteContext } from "./ComponentExecuteContext";
import { ComponentExecutionState } from "./ComponentExecutionState";
import { ReferencedAltitude } from "../core/ReferencedAltitude";
import { FocusCameraCommand } from "../command/camera/FocusCameraCommand";
import { ComponentContext } from "./ComponentContext";
import { FocusRingCameraCommand } from "../command/camera/FocusRingCameraCommand";
import { FacadeComponentModel, FacadeComponentModelData, FacadeComponentModelParameters } from "./FacadeComponentModel";
import { FocusDistanceCameraCommand } from "../command/camera/FocusDistanceCameraCommand";
import { CameraFocusCalibration } from "../core/CameraFocusCalibration";
import { MotionLimits6Optional } from "..";
export declare class FacadeComponent extends ApproachableComponent implements Serializable {
    readonly type = TypeName.FacadeComponent;
    initialAltitude: Altitude;
    finalAltitude: Altitude;
    spacing: FacadeSpacing;
    cameraSpecification: CameraSpecification;
    gimbalOrientations: Dictionary<Orientation3Optional>;
    droneOrientation: Orientation3Optional | null;
    cameraMode: CameraMode;
    cameraPhotoMode: CameraPhotoMode;
    cameraFocusMode: CameraFocusMode;
    cameraFocusCommand: FocusCameraCommand | null;
    cameraFocusDistanceCommand: FocusDistanceCameraCommand | null;
    cameraFocusRingCommand: FocusRingCameraCommand | null;
    captureVerifyFileCreated: boolean;
    capturePriority: CapturePriority;
    captureDroneMotionLimits: MotionLimits6Optional;
    minCaptureInterval: number;
    targetDistance: number;
    sampleDistanceGimbalAngleEnabled: boolean;
    pattern: FacadePattern;
    cornering: PathCornering;
    cornerRadius: number;
    verticalOverlap: number;
    horizontalOverlap: number;
    verticalDistance: number;
    horizontalDistance: number;
    segmentParity: FacadeSegmentParity;
    boundaryFace: FacadeBoundaryFace;
    boundaryPoints: FacadeComponentBoundaryPoint[];
    applyJSON(json: any): void;
    get subtitle(): string;
    toComponentForExecutionEngine(executionEngine: ExecutionEngine, context: ComponentContext): Component | null;
    verification(context: ComponentContext): Component | null;
    cameraCaptureConfigurationsEnabled(context?: ComponentExecuteContext | null): boolean;
    get cameraFocusCalibrationsRequired(): CameraFocusCalibration[];
    alignment(context: ComponentContext): ApproachableAlignment | null;
    get referenceOffsets(): Vector2[];
    referenceOffsetsHandleCoordinate(context: ComponentContext): GeoCoordinate;
    elevationCoordinates(context: ComponentContext): GeoCoordinate[];
    node(parent?: Node | null): ComponentNode;
    centerCoordinate(context: ComponentContext): GeoCoordinate;
    initialReferencedAltitude(context: ComponentContext): ReferencedAltitude;
    finalReferencedAltitude(context: ComponentContext): ReferencedAltitude;
    get surfaceSampleDistance(): GroundSampleDistance;
    resetApproachDestinationOffset(context: ComponentContext): void;
    reverseBoundaryPoints(context: ComponentContext): void;
    addBoundaryPoint(boundaryPoint: FacadeComponentBoundaryPoint, context?: ComponentContext | null, index?: number | null): FacadeComponentBoundaryPoint;
    get boundaryClosed(): boolean;
    updateBoundaryPointCoordinate(index: number, coordinate: GeoCoordinate, context: ComponentContext): void;
    removeBoundaryPoint(boundaryPoint: FacadeComponentBoundaryPoint, context: ComponentContext): FacadeComponentBoundaryPoint;
    get boundaryPointsResolved(): FacadeComponentBoundaryPoint[];
    get boundaryPointOffsets(): Vector2[];
    get maxBoundaryPoints(): number;
    get boundarySegments(): Line2[];
    boundaryRadius(context: ComponentContext): FacadeComponentBoundaryRadius | null;
    boundaryPointCoordinates(context: ComponentContext): GeoCoordinate[];
    boundaryPointCoordinate(context: ComponentContext, index: number): GeoCoordinate;
    get boundaryFaceOrientation(): number;
    endSpatial(context: ComponentContext): GeoSpatial | null;
    estimate(context: ComponentEstimateContext, start: GeoSpatial): ComponentEstimate;
    cachedData(context: ComponentExecuteContext): FacadeComponentModelData | null;
    engaging(context: ComponentExecuteContext, start: GeoSpatial): GeoSpatial[] | null;
    execute(context: ComponentExecuteContext): ComponentExecutionState;
    reengagementDroneSpatial(context: ComponentExecuteContext): GeoSpatial | null;
    paths(context: ComponentContext): Path[] | null;
    get pathCorneringEnabled(): boolean;
    get patternEnabled(): boolean;
    get patternResolved(): FacadePattern;
    private pathsOffsets;
    modelParameters(context: ComponentContext, paths?: Path[] | null): FacadeComponentModelParameters | null;
    model(context: ComponentContext, timeRequired?: boolean): FacadeComponentModel | null;
}
export declare class FacadeComponentBoundaryRadius {
    readonly center: GeoCoordinate;
    readonly boundaryPoints: FacadeComponentBoundaryPoint[];
    constructor(center: GeoCoordinate, boundaryPoints: FacadeComponentBoundaryPoint[]);
    forVerticalPercent(verticalPercent: number): number;
}
